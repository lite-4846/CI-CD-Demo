---
title: Dockerfiles Explained
sidebar_position: 1
---

This section explains how both the **frontend (Angular)** and **backend (Spring Boot)** Dockerfiles work, step-by-step, and how Jenkins uses them while building Docker images.

We’ll break this into two parts — one for the backend, one for the frontend.

---

## 1. Backend Dockerfile

Path: `backend/Dockerfile.backend`

```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY ./artifacts/backend/backend.jar app.jar

EXPOSE 8181

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Step-by-step Breakdown

1. **Base Image**
   - Uses a lightweight OpenJDK 17 image (`openjdk:17-jdk-slim`) suitable for running Spring Boot JARs.
   - Keeps the final image small and secure.

2. **Working Directory**
   - `WORKDIR /app`  
     This creates a working directory inside the container and moves into it. All subsequent commands execute here.

3. **Copy Artifact**
   - `COPY ./artifacts/backend/backend.jar app.jar`  
     Copies the backend JAR (generated by Jenkins in the `artifacts` folder) into the container.

4. **Expose Port**
   - `EXPOSE 8181`  
     Documents the internal container port used by the backend (this does not automatically publish it).

5. **Start the Application**
   - `ENTRYPOINT ["java", "-jar", "app.jar"]`  
     Defines the command to run when the container starts.  
     It executes the JAR just like running `java -jar app.jar` on your machine.

---

### How Jenkins Uses It

In the **backend-docker-image** pipeline:
- Jenkins first verifies that the `backend.jar` exists in the artifacts folder.
- Then it runs:
  ```bash
  docker build -t demo-backend:${BUILD_ID} -f backend/Dockerfile.backend .
  ```
- Docker reads this Dockerfile, copies the JAR from artifacts, and builds a container image.
- The resulting image is tagged (for example `demo-backend:15`) and stored locally for use in `docker-compose.yml`.

---

## 2. Frontend Dockerfile

Path: `angular/Dockerfile.frontend`

```dockerfile
FROM nginx:alpine

RUN rm -rf /usr/share/nginx/html/*

# Copy Angular build
COPY ./artifacts/frontend/demo /demo/angular/dist/demo

# Copy Nginx config
COPY default.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Step-by-step Breakdown

1. **Base Image**
   - Starts from `nginx:alpine`, a small and efficient Nginx image ideal for serving static sites.

2. **Clean Default Nginx Directory**
   - `RUN rm -rf /usr/share/nginx/html/*`  
     Removes the default HTML files shipped with the image, preparing for our own Angular build.

3. **Copy Angular Build Output**
   - `COPY ./artifacts/frontend/demo /demo/angular/dist/demo`  
     The build output (generated by `frontend-app-build` pipeline) is copied into the container under `/demo/angular/dist/demo`.

4. **Add Custom Nginx Config**
   - `COPY default.conf /etc/nginx/conf.d/default.conf`  
     This replaces the default Nginx routing logic with our own — handling frontend routes and backend API proxying.

5. **Expose Port**
   - `EXPOSE 80`  
     Exposes HTTP port 80 (the port Nginx listens on).

6. **Run Nginx**
   - `CMD ["nginx", "-g", "daemon off;"]`  
     Starts Nginx in the foreground. This is the main process of the container.

---

### How Jenkins Uses It

In the **frontend-docker-image** pipeline:
- Jenkins first ensures the frontend build output exists under `artifacts/frontend`.
- Then it runs:
  ```bash
  docker build -t demo-frontend:${BUILD_ID} -f angular/Dockerfile.frontend .
  ```
- Docker copies the built Angular app and Nginx config into the container.
- The final image (`demo-frontend:22` for example) serves the frontend through Nginx on port 80.

---

## Key Takeaway

| Component | Base Image | Source Input | Exposed Port | Run Command | Purpose |
|------------|-------------|---------------|---------------|---------------|-----------|
| Backend | openjdk:17-jdk-slim | backend.jar | 8181 | java -jar app.jar | Runs the Spring Boot API |
| Frontend | nginx:alpine | Angular dist folder | 80 | nginx -g 'daemon off;' | Serves the Angular app |

---

**Next:** We’ll combine both using **Docker Compose** to simulate a production-like environment locally.
